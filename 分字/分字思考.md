# utf8 编码规则：
```
1字节 0xxxxxxx   
2字节 110xxxxx 10xxxxxx   
3字节 1110xxxx 10xxxxxx 10xxxxxx   
4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx   
5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx   
6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx    
```
# 愚钝之下的一些奇葩思考
- 按照字节做位操作，考虑与操作
  - 为什么做位操作呢？按照utf8编码规则，首字节的位分布是有规律的
  - 假如文本每个字节与设计好的字节做与操作，结果对应上图中的某一个首字节分布，则文本当前字节所在的位置加上上图对应的字节大小就是一个确定的语言符号
  - 当前设计和上图每个字节做与操作的位分布
    - byte & 1000 0000 == 0000 0000
    - byte & 1110 0000 == 1100 0000
    - byte & 1111 0000 == 1110 0000
    - byte & 1111 1000 == 1111 0000
    - byte & 1111 1100 == 1111 1000
  - 在当前与操作的基础上，举例[ byte & 1000 0000 == 0000 0000 ],我有想过为什么不是这样子: [ byte & 0000 0000 == 0000 0000 ]? 自我感觉有些奇葩，为什
  么有这种想法呢？[ 0 & 0 == 0; 1 & 0 == 0 ]，没法判断当前字节独占一字节的，可能我这时候在做梦
- 整体思路：
  - 读取文本每行数据
  - 按照字节，遍历每行的数据
  - 参照设计的位操作，判断当前字节是独占一字节或者是多个字节
  - 如果当前字节独占，那就当前字节索引加1，分割出一个字符，从下个字节继续参照位操作判断
  - 如果当前字节是多字节的字符的首字节，则当前字节索引加对应字节数，分割出一个字符，从下个字节继续参照位操作判断
  - 依据以上，按行处理，直至文本读取结束
